"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.handleConverseStreamMetadata = exports.handleConverseStreamContentBlockStart = exports.handleConverseStreamContentBlockDelta = exports.convertConverseMessageToLangChainMessage = exports.convertToBedrockToolChoice = exports.convertToConverseTools = exports.isBedrockTool = exports.convertToConverseMessages = exports.extractImageInfo = void 0;
const messages_1 = require("@langchain/core/messages");
const base_1 = require("@langchain/core/language_models/base");
const function_calling_1 = require("@langchain/core/utils/function_calling");
const zod_to_json_schema_1 = require("zod-to-json-schema");
const outputs_1 = require("@langchain/core/outputs");
function extractImageInfo(base64) {
    // Extract the format from the base64 string
    const formatMatch = base64.match(/^data:image\/(\w+);base64,/);
    let format;
    if (formatMatch) {
        const extractedFormat = formatMatch[1].toLowerCase();
        if (["gif", "jpeg", "png", "webp"].includes(extractedFormat)) {
            format = extractedFormat;
        }
    }
    // Remove the data URL prefix if present
    const base64Data = base64.replace(/^data:image\/\w+;base64,/, "");
    // Convert base64 to Uint8Array
    const binaryString = atob(base64Data);
    const bytes = new Uint8Array(binaryString.length);
    for (let i = 0; i < binaryString.length; i += 1) {
        bytes[i] = binaryString.charCodeAt(i);
    }
    return {
        image: {
            format,
            source: {
                bytes,
            },
        },
    };
}
exports.extractImageInfo = extractImageInfo;
function convertToConverseMessages(messages) {
    const converseSystem = messages
        .filter((msg) => msg._getType() === "system")
        .map((msg) => {
        const text = msg.content;
        if (typeof text !== "string") {
            throw new Error("System message content must be a string.");
        }
        return { text };
    });
    const converseMessages = messages
        .filter((msg) => !["system", "tool", "function"].includes(msg._getType()))
        .map((msg) => {
        if (msg._getType() === "ai") {
            const castMsg = msg;
            if (typeof castMsg.content === "string") {
                return {
                    role: "assistant",
                    content: [
                        {
                            text: castMsg.content,
                        },
                    ],
                };
            }
            else {
                if (castMsg.tool_calls && castMsg.tool_calls.length) {
                    return {
                        role: "assistant",
                        content: castMsg.tool_calls.map((tc) => ({
                            toolUse: {
                                toolUseId: tc.id,
                                name: tc.name,
                                input: tc.args,
                            },
                        })),
                    };
                }
                else {
                    const contentBlocks = castMsg.content.map((block) => {
                        if (block.type === "text") {
                            return {
                                text: block.text,
                            };
                        }
                        else {
                            throw new Error(`Unsupported content block type: ${block.type}`);
                        }
                    });
                    return {
                        role: "assistant",
                        content: contentBlocks,
                    };
                }
            }
        }
        else if (msg._getType() === "human" || msg._getType() === "generic") {
            if (typeof msg.content === "string") {
                return {
                    role: "user",
                    content: [
                        {
                            text: msg.content,
                        },
                    ],
                };
            }
            else {
                const contentBlocks = msg.content.flatMap((block) => {
                    if (block.type === "image_url") {
                        const base64 = typeof block.image_url === "string"
                            ? block.image_url
                            : block.image_url.url;
                        return extractImageInfo(base64);
                    }
                    else if (block.type === "text") {
                        return {
                            text: block.text,
                        };
                    }
                    else {
                        throw new Error(`Unsupported content block type: ${block.type}`);
                    }
                });
                return {
                    role: "user",
                    content: contentBlocks,
                };
            }
        }
        else if (msg._getType() === "tool") {
            const castMsg = msg;
            if (typeof castMsg.content === "string") {
                return {
                    role: undefined,
                    content: [
                        {
                            toolResult: {
                                toolUseId: castMsg.tool_call_id,
                                content: [
                                    {
                                        text: castMsg.content,
                                    },
                                ],
                            },
                        },
                    ],
                };
            }
            else {
                return {
                    role: undefined,
                    content: [
                        {
                            toolResult: {
                                toolUseId: castMsg.tool_call_id,
                                content: [
                                    {
                                        json: castMsg.content,
                                    },
                                ],
                            },
                        },
                    ],
                };
            }
        }
        else {
            throw new Error(`Unsupported message type: ${msg._getType()}`);
        }
    });
    return { converseMessages, converseSystem };
}
exports.convertToConverseMessages = convertToConverseMessages;
function isBedrockTool(tool) {
    if (typeof tool === "object" && tool && "toolSpec" in tool) {
        return true;
    }
    return false;
}
exports.isBedrockTool = isBedrockTool;
function convertToConverseTools(tools) {
    if (tools.every(base_1.isOpenAITool)) {
        return tools.map((tool) => ({
            toolSpec: {
                name: tool.function.name,
                description: tool.function.description,
                inputSchema: {
                    json: tool.function.parameters,
                },
            },
        }));
    }
    else if (tools.every(function_calling_1.isStructuredTool)) {
        return tools.map((tool) => ({
            toolSpec: {
                name: tool.name,
                description: tool.description,
                inputSchema: {
                    json: (0, zod_to_json_schema_1.zodToJsonSchema)(tool.schema),
                },
            },
        }));
    }
    else if (tools.every(isBedrockTool)) {
        return tools;
    }
    throw new Error("Invalid tools passed. Must be an array of StructuredToolInterface, ToolDefinition, or BedrockTool.");
}
exports.convertToConverseTools = convertToConverseTools;
function convertToBedrockToolChoice(toolChoice, tools) {
    if (typeof toolChoice === "string") {
        switch (toolChoice) {
            case "any":
                return {
                    any: {},
                };
            case "auto":
                return {
                    auto: {},
                };
            default: {
                const foundTool = tools.find((tool) => tool.toolSpec?.name === toolChoice);
                if (!foundTool) {
                    throw new Error(`Tool with name ${toolChoice} not found in tools list.`);
                }
                return {
                    tool: {
                        name: toolChoice,
                    },
                };
            }
        }
    }
    return toolChoice;
}
exports.convertToBedrockToolChoice = convertToBedrockToolChoice;
function convertConverseMessageToLangChainMessage(message, responseMetadata) {
    if (!message.content) {
        throw new Error("No message content found in response.");
    }
    if (message.role !== "assistant") {
        throw new Error(`Unsupported message role received in ChatBedrockConverse response: ${message.role}`);
    }
    let requestId;
    if ("$metadata" in responseMetadata &&
        responseMetadata.$metadata &&
        typeof responseMetadata.$metadata === "object" &&
        "requestId" in responseMetadata.$metadata) {
        requestId = responseMetadata.$metadata.requestId;
    }
    let tokenUsage;
    if (responseMetadata.usage) {
        const input_tokens = responseMetadata.usage.inputTokens ?? 0;
        const output_tokens = responseMetadata.usage.outputTokens ?? 0;
        tokenUsage = {
            input_tokens,
            output_tokens,
            total_tokens: responseMetadata.usage.totalTokens ?? input_tokens + output_tokens,
        };
    }
    if (message.content?.length === 1 &&
        "text" in message.content[0] &&
        typeof message.content[0].text === "string") {
        return new messages_1.AIMessage({
            content: message.content[0].text,
            response_metadata: responseMetadata,
            usage_metadata: tokenUsage,
            id: requestId,
        });
    }
    else {
        const toolCalls = [];
        const content = [];
        message.content.forEach((c) => {
            if ("toolUse" in c &&
                c.toolUse &&
                c.toolUse.name &&
                c.toolUse.input &&
                typeof c.toolUse.input === "object") {
                toolCalls.push({
                    id: c.toolUse.toolUseId,
                    name: c.toolUse.name,
                    args: c.toolUse.input,
                });
            }
            else if ("text" in c && typeof c.text === "string") {
                content.push({ type: "text", text: c.text });
            }
            else {
                content.push(c);
            }
        });
        return new messages_1.AIMessage({
            content: content.length ? content : "",
            tool_calls: toolCalls.length ? toolCalls : undefined,
            response_metadata: responseMetadata,
            usage_metadata: tokenUsage,
            id: requestId,
        });
    }
}
exports.convertConverseMessageToLangChainMessage = convertConverseMessageToLangChainMessage;
function handleConverseStreamContentBlockDelta(contentBlockDelta) {
    if (!contentBlockDelta.delta) {
        throw new Error("No delta found in content block.");
    }
    if (contentBlockDelta.delta.text) {
        return new outputs_1.ChatGenerationChunk({
            text: contentBlockDelta.delta.text,
            message: new messages_1.AIMessageChunk({
                content: contentBlockDelta.delta.text,
            }),
        });
    }
    else if (contentBlockDelta.delta.toolUse) {
        const index = contentBlockDelta.contentBlockIndex;
        return new outputs_1.ChatGenerationChunk({
            text: "",
            message: new messages_1.AIMessageChunk({
                content: "",
                tool_call_chunks: [
                    {
                        args: contentBlockDelta.delta.toolUse.input,
                        index,
                    },
                ],
            }),
        });
    }
    else {
        const unsupportedField = Object.entries(contentBlockDelta.delta).filter(([_, value]) => !!value);
        throw new Error(`Unsupported content block type: ${unsupportedField[0][0]}`);
    }
}
exports.handleConverseStreamContentBlockDelta = handleConverseStreamContentBlockDelta;
function handleConverseStreamContentBlockStart(contentBlockStart) {
    const index = contentBlockStart.contentBlockIndex;
    if (contentBlockStart.start?.toolUse) {
        return new outputs_1.ChatGenerationChunk({
            text: "",
            message: new messages_1.AIMessageChunk({
                content: "",
                tool_call_chunks: [
                    {
                        name: contentBlockStart.start.toolUse.name,
                        id: contentBlockStart.start.toolUse.toolUseId,
                        index,
                    },
                ],
            }),
        });
    }
    throw new Error("Unsupported content block start event.");
}
exports.handleConverseStreamContentBlockStart = handleConverseStreamContentBlockStart;
function handleConverseStreamMetadata(metadata, extra) {
    const inputTokens = metadata.usage?.inputTokens ?? 0;
    const outputTokens = metadata.usage?.outputTokens ?? 0;
    const usage_metadata = {
        input_tokens: inputTokens,
        output_tokens: outputTokens,
        total_tokens: metadata.usage?.totalTokens ?? inputTokens + outputTokens,
    };
    return new outputs_1.ChatGenerationChunk({
        text: "",
        message: new messages_1.AIMessageChunk({
            content: "",
            usage_metadata: extra.streamUsage ? usage_metadata : undefined,
            response_metadata: {
                // Use the same key as returned from the Converse API
                metadata,
            },
        }),
    });
}
exports.handleConverseStreamMetadata = handleConverseStreamMetadata;
